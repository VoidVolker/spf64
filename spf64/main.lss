
main.o:     file format elf64-x86-64
main.o
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000b9e  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000be0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000c  0000000000000000  0000000000000000  00000be0  2**2
                  ALLOC
  3 .rodata       0000000c  0000000000000000  0000000000000000  00000be0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000de9  0000000000000000  0000000000000000  00000bec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000318  0000000000000000  0000000000000000  000019d5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000112c  0000000000000000  0000000000000000  00001ced  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000030  0000000000000000  0000000000000000  00002e19  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000285  0000000000000000  0000000000000000  00002e49  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000496  0000000000000000  0000000000000000  000030ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000001d  0000000000000000  0000000000000000  00003564  2**0
                  CONTENTS, READONLY
 11 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00003581  2**0
                  CONTENTS, READONLY
 12 .eh_frame     000005e0  0000000000000000  0000000000000000  00003588  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 main.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .rodata	0000000000000000 .rodata
0000000000000004 l     O .bss	0000000000000004 ASCREEN
0000000000000008 l     O .bss	0000000000000004 scrn
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_loc	0000000000000000 .debug_loc
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000008       O *COM*	0000000000000008 FP
0000000000001f50       O *COM*	0000000000000020 FPBuf
0000000000000000 g     F .text	0000000000000027 _0e
0000000000000027 g     F .text	000000000000002c x1e
0000000000000053 g     F .text	000000000000007e ZTO_FLOAT
0000000000000000         *UND*	0000000000000000 strtod
0000000000000000         *UND*	0000000000000000 isspace
0000000000000028       O *COM*	0000000000000020 buf
0000000000000004       O *COM*	0000000000000004 ii
00000000000000d1 g     F .text	000000000000006f F_dot_STR
0000000000000000         *UND*	0000000000000000 sprintf
0000000000000140 g     F .text	0000000000000026 f_store
0000000000000166 g     F .text	0000000000000045 f_plus
00000000000001ab g     F .text	0000000000000045 f_minus
00000000000001f0 g     F .text	0000000000000045 f_star
0000000000000235 g     F .text	0000000000000045 f_slash
000000000000027a g     F .text	000000000000002c f_zero_less
00000000000002a6 g     F .text	000000000000002c f_zero_equal
00000000000002d2 g     F .text	0000000000000042 f_less_than
0000000000000314 g     F .text	0000000000000016 f_to_d
000000000000032a g     F .text	000000000000002d f_fetch
0000000000000357 g     F .text	0000000000000044 ss_to_f
000000000000039b g     F .text	000000000000002d d_to_f
00000000000003c8 g     F .text	000000000000000b FCELL_
00000000000003d3 g     F .text	0000000000000011 f_init
00000000000003e4 g     F .text	000000000000001a f_tst
0000000000000000         *UND*	0000000000000000 _1e
0000000000000000         *UND*	0000000000000000 Fdot
00000000000003fe g     F .text	0000000000000010 f_tst1
000000000000040e g     F .text	0000000000000010 f_tst2
0000000000000008       O *COM*	0000000000000008 ARGV1
000000000000041e g     F .text	000000000000000b RWGet
0000000000000429 g     F .text	000000000000000b ROGet
0000000000000434 g     F .text	000000000000000b WOGet
000000000000043f g     F .text	000000000000000b SEEK_SETGet
000000000000044a g     F .text	000000000000000b O_CREATGet
0000000000000455 g     F .text	0000000000000021 HPOINT
0000000000000000         *UND*	0000000000000000 printf
0000000000000476 g     F .text	0000000000000021 mtell
0000000000000000         *UND*	0000000000000000 lseek
0000000000000497 g     F .text	0000000000000028 rmlseek
00000000000004bf g     F .text	0000000000000029 mlseek
00000000000004e8 g     F .text	000000000000002c LOPEN
0000000000000000         *UND*	0000000000000000 open
0000000000000514 g     F .text	000000000000005a LACCEPT
0000000000000000         *UND*	0000000000000000 stdin
0000000000000000         *UND*	0000000000000000 fgets
0000000000000000         *UND*	0000000000000000 strrchr
0000000000000000         *UND*	0000000000000000 strlen
000000000000056e g     F .text	000000000000000d LARGV1
000000000000057b g     F .text	000000000000001a LZTYPE
0000000000000000         *UND*	0000000000000000 puts
0000000000000595 g     F .text	000000000000000e LBYE
0000000000000000         *UND*	0000000000000000 exit
000000000000003c       O *COM*	0000000000000020 tios0
0000000000000000 g     O .bss	0000000000000001 key_query_char
00000000000005a3 g     F .text	0000000000000015 save_term
0000000000000000         *UND*	0000000000000000 tcgetattr
00000000000005b8 g     F .text	000000000000001a restore_term
0000000000000000         *UND*	0000000000000000 tcsetattr
00000000000005d2 g     F .text	000000000000003a echo_off
000000000000060c g     F .text	000000000000003a echo_on
0000000000000646 g     F .text	0000000000000107 C_KEY
0000000000000000         *UND*	0000000000000000 read
000000000000074d g     F .text	000000000000010f C_KEYQUERY
000000000000085c g     F .text	00000000000001c9 C_ACCEPT
0000000000000000         *UND*	0000000000000000 write
0000000000000a25 g     F .text	00000000000000db L_ACCEPT
0000000000000b00 g     F .text	0000000000000054 wherexy
0000000000000b54 g     F .text	0000000000000010 zzzz
0000000000000b64 g     F .text	000000000000003a main
0000000000000000         *UND*	0000000000000000 amain



Disassembly of section .text:

0000000000000000 <_0e>:

double *FP;
double  FPBuf[FPBufSize];

void _0e()
{	FP--;
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # b <_0e+0xb>
			7: R_X86_64_PC32	FP+0xfffffffffffffffc
   b:	48 83 e8 08          	sub    $0x8,%rax
   f:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 16 <_0e+0x16>
			12: R_X86_64_PC32	FP+0xfffffffffffffffc
	FP[0] = 0.0;
  16:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1d <_0e+0x1d>
			19: R_X86_64_PC32	FP+0xfffffffffffffffc
  1d:	b8 00 00 00 00       	mov    $0x0,%eax
  22:	48 89 02             	mov    %rax,(%rdx)
}
  25:	5d                   	pop    %rbp
  26:	c3                   	retq   

0000000000000027 <x1e>:

void x1e()
{	FP--;
  27:	55                   	push   %rbp
  28:	48 89 e5             	mov    %rsp,%rbp
  2b:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 32 <x1e+0xb>
			2e: R_X86_64_PC32	FP+0xfffffffffffffffc
  32:	48 83 e8 08          	sub    $0x8,%rax
  36:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 3d <x1e+0x16>
			39: R_X86_64_PC32	FP+0xfffffffffffffffc
	FP[0] = 1.0;
  3d:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 44 <x1e+0x1d>
			40: R_X86_64_PC32	FP+0xfffffffffffffffc
  44:	48 b8 00 00 00 00 00 	movabs $0x3ff0000000000000,%rax
  4b:	00 f0 3f 
  4e:	48 89 02             	mov    %rax,(%rdx)
}
  51:	5d                   	pop    %rbp
  52:	c3                   	retq   

0000000000000053 <ZTO_FLOAT>:

int ZTO_FLOAT(char *szInput)
{ char * pEnd; 
  53:	55                   	push   %rbp
  54:	48 89 e5             	mov    %rsp,%rbp
  57:	53                   	push   %rbx
  58:	48 83 ec 28          	sub    $0x28,%rsp
  5c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	FP--;
  60:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 67 <ZTO_FLOAT+0x14>
			63: R_X86_64_PC32	FP+0xfffffffffffffffc
  67:	48 83 e8 08          	sub    $0x8,%rax
  6b:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 72 <ZTO_FLOAT+0x1f>
			6e: R_X86_64_PC32	FP+0xfffffffffffffffc
	FP[0] = strtod (szInput,&pEnd);
  72:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 79 <ZTO_FLOAT+0x26>
			75: R_X86_64_PC32	FP+0xfffffffffffffffc
  79:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81:	48 89 d6             	mov    %rdx,%rsi
  84:	48 89 c7             	mov    %rax,%rdi
  87:	e8 00 00 00 00       	callq  8c <ZTO_FLOAT+0x39>
			88: R_X86_64_PC32	strtod+0xfffffffffffffffc
  8c:	f2 0f 11 45 d0       	movsd  %xmm0,-0x30(%rbp)
  91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  95:	48 89 03             	mov    %rax,(%rbx)
//	if (pEnd == NULL)	return -1;
	while (isspace (*pEnd))	pEnd++;
  98:	eb 0c                	jmp    a6 <ZTO_FLOAT+0x53>
  9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  9e:	48 83 c0 01          	add    $0x1,%rax
  a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  aa:	0f b6 00             	movzbl (%rax),%eax
  ad:	0f be c0             	movsbl %al,%eax
  b0:	89 c7                	mov    %eax,%edi
  b2:	e8 00 00 00 00       	callq  b7 <ZTO_FLOAT+0x64>
			b3: R_X86_64_PC32	isspace+0xfffffffffffffffc
  b7:	85 c0                	test   %eax,%eax
  b9:	75 df                	jne    9a <ZTO_FLOAT+0x47>
	return *pEnd == '\0';
  bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  bf:	0f b6 00             	movzbl (%rax),%eax
  c2:	84 c0                	test   %al,%al
  c4:	0f 94 c0             	sete   %al
  c7:	0f b6 c0             	movzbl %al,%eax
}
  ca:	48 83 c4 28          	add    $0x28,%rsp
  ce:	5b                   	pop    %rbx
  cf:	5d                   	pop    %rbp
  d0:	c3                   	retq   

00000000000000d1 <F_dot_STR>:

char buf[40];
int ii;
char * F_dot_STR()
{
  d1:	55                   	push   %rbp
  d2:	48 89 e5             	mov    %rsp,%rbp
  d5:	48 83 ec 10          	sub    $0x10,%rsp
   sprintf (buf,"%lf",*FP++);
  d9:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # e0 <F_dot_STR+0xf>
			dc: R_X86_64_PC32	FP+0xfffffffffffffffc
  e0:	48 8b 02             	mov    (%rdx),%rax
  e3:	48 83 c2 08          	add    $0x8,%rdx
  e7:	48 89 15 00 00 00 00 	mov    %rdx,0x0(%rip)        # ee <F_dot_STR+0x1d>
			ea: R_X86_64_PC32	FP+0xfffffffffffffffc
  ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  f2:	f2 0f 10 45 f8       	movsd  -0x8(%rbp),%xmm0
  f7:	be 00 00 00 00       	mov    $0x0,%esi
			f8: R_X86_64_32	.rodata
  fc:	bf 00 00 00 00       	mov    $0x0,%edi
			fd: R_X86_64_32	buf
 101:	b8 01 00 00 00       	mov    $0x1,%eax
 106:	e8 00 00 00 00       	callq  10b <F_dot_STR+0x3a>
			107: R_X86_64_PC32	sprintf+0xfffffffffffffffc
   for(ii=0;buf[ii];ii++);
 10b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 115 <F_dot_STR+0x44>
 112:	00 00 00 
			10d: R_X86_64_PC32	ii+0xfffffffffffffff8
 115:	eb 0f                	jmp    126 <F_dot_STR+0x55>
 117:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 11d <F_dot_STR+0x4c>
			119: R_X86_64_PC32	ii+0xfffffffffffffffc
 11d:	83 c0 01             	add    $0x1,%eax
 120:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 126 <F_dot_STR+0x55>
			122: R_X86_64_PC32	ii+0xfffffffffffffffc
 126:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 12c <F_dot_STR+0x5b>
			128: R_X86_64_PC32	ii+0xfffffffffffffffc
 12c:	48 98                	cltq   
 12e:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			131: R_X86_64_32S	buf
 135:	84 c0                	test   %al,%al
 137:	75 de                	jne    117 <F_dot_STR+0x46>
// write (0,buf, ii);
   return &buf;
 139:	b8 00 00 00 00       	mov    $0x0,%eax
			13a: R_X86_64_32	buf
}
 13e:	c9                   	leaveq 
 13f:	c3                   	retq   

0000000000000140 <f_store>:

void f_store( double * sp0 )
{  * sp0 = *FP++;
 140:	55                   	push   %rbp
 141:	48 89 e5             	mov    %rsp,%rbp
 144:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 148:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 14f <f_store+0xf>
			14b: R_X86_64_PC32	FP+0xfffffffffffffffc
 14f:	48 8b 02             	mov    (%rdx),%rax
 152:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
 156:	48 89 01             	mov    %rax,(%rcx)
 159:	48 8d 42 08          	lea    0x8(%rdx),%rax
 15d:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 164 <f_store+0x24>
			160: R_X86_64_PC32	FP+0xfffffffffffffffc
}
 164:	5d                   	pop    %rbp
 165:	c3                   	retq   

0000000000000166 <f_plus>:
void f_plus()
{   FP[1] += FP[0];
 166:	55                   	push   %rbp
 167:	48 89 e5             	mov    %rsp,%rbp
 16a:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 171 <f_plus+0xb>
			16d: R_X86_64_PC32	FP+0xfffffffffffffffc
 171:	48 8d 50 08          	lea    0x8(%rax),%rdx
 175:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 17c <f_plus+0x16>
			178: R_X86_64_PC32	FP+0xfffffffffffffffc
 17c:	48 83 c0 08          	add    $0x8,%rax
 180:	f2 0f 10 08          	movsd  (%rax),%xmm1
 184:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 18b <f_plus+0x25>
			187: R_X86_64_PC32	FP+0xfffffffffffffffc
 18b:	f2 0f 10 00          	movsd  (%rax),%xmm0
 18f:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
 193:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
    FP++;
 197:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 19e <f_plus+0x38>
			19a: R_X86_64_PC32	FP+0xfffffffffffffffc
 19e:	48 83 c0 08          	add    $0x8,%rax
 1a2:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1a9 <f_plus+0x43>
			1a5: R_X86_64_PC32	FP+0xfffffffffffffffc
}
 1a9:	5d                   	pop    %rbp
 1aa:	c3                   	retq   

00000000000001ab <f_minus>:
void f_minus()
{   FP[1] -= FP[0];
 1ab:	55                   	push   %rbp
 1ac:	48 89 e5             	mov    %rsp,%rbp
 1af:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1b6 <f_minus+0xb>
			1b2: R_X86_64_PC32	FP+0xfffffffffffffffc
 1b6:	48 8d 50 08          	lea    0x8(%rax),%rdx
 1ba:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1c1 <f_minus+0x16>
			1bd: R_X86_64_PC32	FP+0xfffffffffffffffc
 1c1:	48 83 c0 08          	add    $0x8,%rax
 1c5:	f2 0f 10 00          	movsd  (%rax),%xmm0
 1c9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1d0 <f_minus+0x25>
			1cc: R_X86_64_PC32	FP+0xfffffffffffffffc
 1d0:	f2 0f 10 08          	movsd  (%rax),%xmm1
 1d4:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
 1d8:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
    FP++;
 1dc:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e3 <f_minus+0x38>
			1df: R_X86_64_PC32	FP+0xfffffffffffffffc
 1e3:	48 83 c0 08          	add    $0x8,%rax
 1e7:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1ee <f_minus+0x43>
			1ea: R_X86_64_PC32	FP+0xfffffffffffffffc
}
 1ee:	5d                   	pop    %rbp
 1ef:	c3                   	retq   

00000000000001f0 <f_star>:

void f_star()
{   FP[1] *= FP[0];
 1f0:	55                   	push   %rbp
 1f1:	48 89 e5             	mov    %rsp,%rbp
 1f4:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1fb <f_star+0xb>
			1f7: R_X86_64_PC32	FP+0xfffffffffffffffc
 1fb:	48 8d 50 08          	lea    0x8(%rax),%rdx
 1ff:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 206 <f_star+0x16>
			202: R_X86_64_PC32	FP+0xfffffffffffffffc
 206:	48 83 c0 08          	add    $0x8,%rax
 20a:	f2 0f 10 08          	movsd  (%rax),%xmm1
 20e:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 215 <f_star+0x25>
			211: R_X86_64_PC32	FP+0xfffffffffffffffc
 215:	f2 0f 10 00          	movsd  (%rax),%xmm0
 219:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
 21d:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
    FP++;
 221:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 228 <f_star+0x38>
			224: R_X86_64_PC32	FP+0xfffffffffffffffc
 228:	48 83 c0 08          	add    $0x8,%rax
 22c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 233 <f_star+0x43>
			22f: R_X86_64_PC32	FP+0xfffffffffffffffc
}
 233:	5d                   	pop    %rbp
 234:	c3                   	retq   

0000000000000235 <f_slash>:

void f_slash()
{   FP[1] /= FP[0];
 235:	55                   	push   %rbp
 236:	48 89 e5             	mov    %rsp,%rbp
 239:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 240 <f_slash+0xb>
			23c: R_X86_64_PC32	FP+0xfffffffffffffffc
 240:	48 8d 50 08          	lea    0x8(%rax),%rdx
 244:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 24b <f_slash+0x16>
			247: R_X86_64_PC32	FP+0xfffffffffffffffc
 24b:	48 83 c0 08          	add    $0x8,%rax
 24f:	f2 0f 10 00          	movsd  (%rax),%xmm0
 253:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 25a <f_slash+0x25>
			256: R_X86_64_PC32	FP+0xfffffffffffffffc
 25a:	f2 0f 10 08          	movsd  (%rax),%xmm1
 25e:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
 262:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
    FP++;
 266:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 26d <f_slash+0x38>
			269: R_X86_64_PC32	FP+0xfffffffffffffffc
 26d:	48 83 c0 08          	add    $0x8,%rax
 271:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 278 <f_slash+0x43>
			274: R_X86_64_PC32	FP+0xfffffffffffffffc
}
 278:	5d                   	pop    %rbp
 279:	c3                   	retq   

000000000000027a <f_zero_less>:

int f_zero_less()
{  return *FP++ < 0 ;
 27a:	55                   	push   %rbp
 27b:	48 89 e5             	mov    %rsp,%rbp
 27e:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 285 <f_zero_less+0xb>
			281: R_X86_64_PC32	FP+0xfffffffffffffffc
 285:	f2 0f 10 08          	movsd  (%rax),%xmm1
 289:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
 28d:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
 291:	0f 97 c2             	seta   %dl
 294:	0f b6 d2             	movzbl %dl,%edx
 297:	48 83 c0 08          	add    $0x8,%rax
 29b:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 2a2 <f_zero_less+0x28>
			29e: R_X86_64_PC32	FP+0xfffffffffffffffc
 2a2:	89 d0                	mov    %edx,%eax
}
 2a4:	5d                   	pop    %rbp
 2a5:	c3                   	retq   

00000000000002a6 <f_zero_equal>:
int f_zero_equal() 
{  return *FP++ < 0 ;
 2a6:	55                   	push   %rbp
 2a7:	48 89 e5             	mov    %rsp,%rbp
 2aa:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2b1 <f_zero_equal+0xb>
			2ad: R_X86_64_PC32	FP+0xfffffffffffffffc
 2b1:	f2 0f 10 08          	movsd  (%rax),%xmm1
 2b5:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
 2b9:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
 2bd:	0f 97 c2             	seta   %dl
 2c0:	0f b6 d2             	movzbl %dl,%edx
 2c3:	48 83 c0 08          	add    $0x8,%rax
 2c7:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 2ce <f_zero_equal+0x28>
			2ca: R_X86_64_PC32	FP+0xfffffffffffffffc
 2ce:	89 d0                	mov    %edx,%eax
}
 2d0:	5d                   	pop    %rbp
 2d1:	c3                   	retq   

00000000000002d2 <f_less_than>:
int f_less_than()
{ int sp0;
 2d2:	55                   	push   %rbp
 2d3:	48 89 e5             	mov    %rsp,%rbp
 sp0 = FP[1] < FP[0] ;
 2d6:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2dd <f_less_than+0xb>
			2d9: R_X86_64_PC32	FP+0xfffffffffffffffc
 2dd:	48 83 c0 08          	add    $0x8,%rax
 2e1:	f2 0f 10 08          	movsd  (%rax),%xmm1
 2e5:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2ec <f_less_than+0x1a>
			2e8: R_X86_64_PC32	FP+0xfffffffffffffffc
 2ec:	f2 0f 10 00          	movsd  (%rax),%xmm0
 2f0:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
 2f4:	0f 97 c0             	seta   %al
 2f7:	0f b6 c0             	movzbl %al,%eax
 2fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
 FP += 2;
 2fd:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 304 <f_less_than+0x32>
			300: R_X86_64_PC32	FP+0xfffffffffffffffc
 304:	48 83 c0 10          	add    $0x10,%rax
 308:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 30f <f_less_than+0x3d>
			30b: R_X86_64_PC32	FP+0xfffffffffffffffc
 return sp0;
 30f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
 312:	5d                   	pop    %rbp
 313:	c3                   	retq   

0000000000000314 <f_to_d>:

long long f_to_d()
{  return (long long)(*FP);
 314:	55                   	push   %rbp
 315:	48 89 e5             	mov    %rsp,%rbp
 318:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 31f <f_to_d+0xb>
			31b: R_X86_64_PC32	FP+0xfffffffffffffffc
 31f:	f2 0f 10 00          	movsd  (%rax),%xmm0
 323:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
}
 328:	5d                   	pop    %rbp
 329:	c3                   	retq   

000000000000032a <f_fetch>:

void f_fetch( double * sp0 )
{ *--FP = *sp0;
 32a:	55                   	push   %rbp
 32b:	48 89 e5             	mov    %rsp,%rbp
 32e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 332:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 339 <f_fetch+0xf>
			335: R_X86_64_PC32	FP+0xfffffffffffffffc
 339:	48 83 e8 08          	sub    $0x8,%rax
 33d:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 344 <f_fetch+0x1a>
			340: R_X86_64_PC32	FP+0xfffffffffffffffc
 344:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 34b <f_fetch+0x21>
			347: R_X86_64_PC32	FP+0xfffffffffffffffc
 34b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 34f:	48 8b 00             	mov    (%rax),%rax
 352:	48 89 02             	mov    %rax,(%rdx)
}
 355:	5d                   	pop    %rbp
 356:	c3                   	retq   

0000000000000357 <ss_to_f>:
void ss_to_f ( int sp1, int sp0)
{ FP--;
 357:	55                   	push   %rbp
 358:	48 89 e5             	mov    %rsp,%rbp
 35b:	89 7d fc             	mov    %edi,-0x4(%rbp)
 35e:	89 75 f8             	mov    %esi,-0x8(%rbp)
 361:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 368 <ss_to_f+0x11>
			364: R_X86_64_PC32	FP+0xfffffffffffffffc
 368:	48 83 e8 08          	sub    $0x8,%rax
 36c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 373 <ss_to_f+0x1c>
			36f: R_X86_64_PC32	FP+0xfffffffffffffffc
  FP[0] = (double)( ((long long)(sp0)>>32) + sp1 );
 373:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 37a <ss_to_f+0x23>
			376: R_X86_64_PC32	FP+0xfffffffffffffffc
 37a:	8b 55 f8             	mov    -0x8(%rbp),%edx
 37d:	48 63 d2             	movslq %edx,%rdx
 380:	48 89 d1             	mov    %rdx,%rcx
 383:	48 c1 f9 20          	sar    $0x20,%rcx
 387:	8b 55 fc             	mov    -0x4(%rbp),%edx
 38a:	48 63 d2             	movslq %edx,%rdx
 38d:	48 01 ca             	add    %rcx,%rdx
 390:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
 395:	f2 0f 11 00          	movsd  %xmm0,(%rax)
}
 399:	5d                   	pop    %rbp
 39a:	c3                   	retq   

000000000000039b <d_to_f>:

void d_to_f ( long long sp)
{ FP--;
 39b:	55                   	push   %rbp
 39c:	48 89 e5             	mov    %rsp,%rbp
 39f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 3a3:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3aa <d_to_f+0xf>
			3a6: R_X86_64_PC32	FP+0xfffffffffffffffc
 3aa:	48 83 e8 08          	sub    $0x8,%rax
 3ae:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 3b5 <d_to_f+0x1a>
			3b1: R_X86_64_PC32	FP+0xfffffffffffffffc
  FP[0] = (double)sp;
 3b5:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3bc <d_to_f+0x21>
			3b8: R_X86_64_PC32	FP+0xfffffffffffffffc
 3bc:	f2 48 0f 2a 45 f8    	cvtsi2sdq -0x8(%rbp),%xmm0
 3c2:	f2 0f 11 00          	movsd  %xmm0,(%rax)
}
 3c6:	5d                   	pop    %rbp
 3c7:	c3                   	retq   

00000000000003c8 <FCELL_>:

int FCELL_()
{  return sizeof(double) ;
 3c8:	55                   	push   %rbp
 3c9:	48 89 e5             	mov    %rsp,%rbp
 3cc:	b8 08 00 00 00       	mov    $0x8,%eax
}
 3d1:	5d                   	pop    %rbp
 3d2:	c3                   	retq   

00000000000003d3 <f_init>:

void f_init()
{ FP=&FPBuf[FPBufSize-2];
 3d3:	55                   	push   %rbp
 3d4:	48 89 e5             	mov    %rsp,%rbp
 3d7:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 3e2 <f_init+0xf>
 3de:	00 00 00 00 
			3da: R_X86_64_PC32	FP+0xfffffffffffffff8
			3de: R_X86_64_32S	FPBuf+0x1f40

}
 3e2:	5d                   	pop    %rbp
 3e3:	c3                   	retq   

00000000000003e4 <f_tst>:

void f_tst()
{	_1e();
 3e4:	55                   	push   %rbp
 3e5:	48 89 e5             	mov    %rsp,%rbp
 3e8:	b8 00 00 00 00       	mov    $0x0,%eax
 3ed:	e8 00 00 00 00       	callq  3f2 <f_tst+0xe>
			3ee: R_X86_64_PC32	_1e+0xfffffffffffffffc
	Fdot();
 3f2:	b8 00 00 00 00       	mov    $0x0,%eax
 3f7:	e8 00 00 00 00       	callq  3fc <f_tst+0x18>
			3f8: R_X86_64_PC32	Fdot+0xfffffffffffffffc
}
 3fc:	5d                   	pop    %rbp
 3fd:	c3                   	retq   

00000000000003fe <f_tst1>:

void f_tst1()
{	f_tst();
 3fe:	55                   	push   %rbp
 3ff:	48 89 e5             	mov    %rsp,%rbp
 402:	b8 00 00 00 00       	mov    $0x0,%eax
 407:	e8 00 00 00 00       	callq  40c <f_tst1+0xe>
			408: R_X86_64_PC32	f_tst+0xfffffffffffffffc
}
 40c:	5d                   	pop    %rbp
 40d:	c3                   	retq   

000000000000040e <f_tst2>:

void f_tst2()
{	f_tst1();
 40e:	55                   	push   %rbp
 40f:	48 89 e5             	mov    %rsp,%rbp
 412:	b8 00 00 00 00       	mov    $0x0,%eax
 417:	e8 00 00 00 00       	callq  41c <f_tst2+0xe>
			418: R_X86_64_PC32	f_tst1+0xfffffffffffffffc
}
 41c:	5d                   	pop    %rbp
 41d:	c3                   	retq   

000000000000041e <RWGet>:

char * ARGV1;
//int AAAA=444;

int RWGet()
{  return O_RDWR|O_BINARY ;
 41e:	55                   	push   %rbp
 41f:	48 89 e5             	mov    %rsp,%rbp
 422:	b8 02 00 00 00       	mov    $0x2,%eax
}
 427:	5d                   	pop    %rbp
 428:	c3                   	retq   

0000000000000429 <ROGet>:
int ROGet()
{  return O_RDONLY|O_BINARY ;
 429:	55                   	push   %rbp
 42a:	48 89 e5             	mov    %rsp,%rbp
 42d:	b8 00 00 00 00       	mov    $0x0,%eax
 }
 432:	5d                   	pop    %rbp
 433:	c3                   	retq   

0000000000000434 <WOGet>:
int WOGet()
{  return O_WRONLY|O_BINARY ;
 434:	55                   	push   %rbp
 435:	48 89 e5             	mov    %rsp,%rbp
 438:	b8 01 00 00 00       	mov    $0x1,%eax
}
 43d:	5d                   	pop    %rbp
 43e:	c3                   	retq   

000000000000043f <SEEK_SETGet>:

int SEEK_SETGet() { return SEEK_SET ; }
 43f:	55                   	push   %rbp
 440:	48 89 e5             	mov    %rsp,%rbp
 443:	b8 00 00 00 00       	mov    $0x0,%eax
 448:	5d                   	pop    %rbp
 449:	c3                   	retq   

000000000000044a <O_CREATGet>:
int O_CREATGet() {
 44a:	55                   	push   %rbp
 44b:	48 89 e5             	mov    %rsp,%rbp
 return O_CREAT ;
 44e:	b8 40 00 00 00       	mov    $0x40,%eax
 }
 453:	5d                   	pop    %rbp
 454:	c3                   	retq   

0000000000000455 <HPOINT>:
int add(int aa,int bb)
{ return aa+bb;
} */

void HPOINT(int x)
{   printf("%x ",x);
 455:	55                   	push   %rbp
 456:	48 89 e5             	mov    %rsp,%rbp
 459:	48 83 ec 10          	sub    $0x10,%rsp
 45d:	89 7d fc             	mov    %edi,-0x4(%rbp)
 460:	8b 45 fc             	mov    -0x4(%rbp),%eax
 463:	89 c6                	mov    %eax,%esi
 465:	bf 00 00 00 00       	mov    $0x0,%edi
			466: R_X86_64_32	.rodata+0x4
 46a:	b8 00 00 00 00       	mov    $0x0,%eax
 46f:	e8 00 00 00 00       	callq  474 <HPOINT+0x1f>
			470: R_X86_64_PC32	printf+0xfffffffffffffffc
}
 474:	c9                   	leaveq 
 475:	c3                   	retq   

0000000000000476 <mtell>:

int	mtell(int _fd)
{ return lseek(_fd, (off_t) 0, SEEK_CUR); }
 476:	55                   	push   %rbp
 477:	48 89 e5             	mov    %rsp,%rbp
 47a:	48 83 ec 10          	sub    $0x10,%rsp
 47e:	89 7d fc             	mov    %edi,-0x4(%rbp)
 481:	8b 45 fc             	mov    -0x4(%rbp),%eax
 484:	ba 01 00 00 00       	mov    $0x1,%edx
 489:	be 00 00 00 00       	mov    $0x0,%esi
 48e:	89 c7                	mov    %eax,%edi
 490:	e8 00 00 00 00       	callq  495 <mtell+0x1f>
			491: R_X86_64_PC32	lseek+0xfffffffffffffffc
 495:	c9                   	leaveq 
 496:	c3                   	retq   

0000000000000497 <rmlseek>:

int	rmlseek(int _fd, int off1)
{ return lseek(_fd, (off_t) off1, SEEK_SET); }
 497:	55                   	push   %rbp
 498:	48 89 e5             	mov    %rsp,%rbp
 49b:	48 83 ec 10          	sub    $0x10,%rsp
 49f:	89 7d fc             	mov    %edi,-0x4(%rbp)
 4a2:	89 75 f8             	mov    %esi,-0x8(%rbp)
 4a5:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4a8:	48 63 c8             	movslq %eax,%rcx
 4ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4ae:	ba 00 00 00 00       	mov    $0x0,%edx
 4b3:	48 89 ce             	mov    %rcx,%rsi
 4b6:	89 c7                	mov    %eax,%edi
 4b8:	e8 00 00 00 00       	callq  4bd <rmlseek+0x26>
			4b9: R_X86_64_PC32	lseek+0xfffffffffffffffc
 4bd:	c9                   	leaveq 
 4be:	c3                   	retq   

00000000000004bf <mlseek>:

int	mlseek(int _fd, int off1, int mode)
{ return lseek(_fd, (off_t) off1, mode); }
 4bf:	55                   	push   %rbp
 4c0:	48 89 e5             	mov    %rsp,%rbp
 4c3:	48 83 ec 10          	sub    $0x10,%rsp
 4c7:	89 7d fc             	mov    %edi,-0x4(%rbp)
 4ca:	89 75 f8             	mov    %esi,-0x8(%rbp)
 4cd:	89 55 f4             	mov    %edx,-0xc(%rbp)
 4d0:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4d3:	48 63 c8             	movslq %eax,%rcx
 4d6:	8b 55 f4             	mov    -0xc(%rbp),%edx
 4d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4dc:	48 89 ce             	mov    %rcx,%rsi
 4df:	89 c7                	mov    %eax,%edi
 4e1:	e8 00 00 00 00       	callq  4e6 <mlseek+0x27>
			4e2: R_X86_64_PC32	lseek+0xfffffffffffffffc
 4e6:	c9                   	leaveq 
 4e7:	c3                   	retq   

00000000000004e8 <LOPEN>:

int LOPEN(const char *pathname, int flags)
{ return open(pathname, flags|O_BINARY,S_IREAD | S_IWRITE);
 4e8:	55                   	push   %rbp
 4e9:	48 89 e5             	mov    %rsp,%rbp
 4ec:	48 83 ec 10          	sub    $0x10,%rsp
 4f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4f4:	89 75 f4             	mov    %esi,-0xc(%rbp)
 4f7:	8b 4d f4             	mov    -0xc(%rbp),%ecx
 4fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4fe:	ba 01 00 00 00       	mov    $0x1,%edx
 503:	89 ce                	mov    %ecx,%esi
 505:	48 89 c7             	mov    %rax,%rdi
 508:	b8 00 00 00 00       	mov    $0x0,%eax
 50d:	e8 00 00 00 00       	callq  512 <LOPEN+0x2a>
			50e: R_X86_64_PC32	open+0xfffffffffffffffc
}
 512:	c9                   	leaveq 
 513:	c3                   	retq   

0000000000000514 <LACCEPT>:

int LACCEPT(char *p,int n)
{ register char *q;
 514:	55                   	push   %rbp
 515:	48 89 e5             	mov    %rsp,%rbp
 518:	53                   	push   %rbx
 519:	48 83 ec 18          	sub    $0x18,%rsp
 51d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 521:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  q = fgets (p, n, stdin);
 524:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 52b <LACCEPT+0x17>
			527: R_X86_64_PC32	stdin+0xfffffffffffffffc
 52b:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
 52e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 532:	89 ce                	mov    %ecx,%esi
 534:	48 89 c7             	mov    %rax,%rdi
 537:	e8 00 00 00 00       	callq  53c <LACCEPT+0x28>
			538: R_X86_64_PC32	fgets+0xfffffffffffffffc
 53c:	48 89 c3             	mov    %rax,%rbx
  q = strrchr (p, '\n');
 53f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 543:	be 0a 00 00 00       	mov    $0xa,%esi
 548:	48 89 c7             	mov    %rax,%rdi
 54b:	e8 00 00 00 00       	callq  550 <LACCEPT+0x3c>
			54c: R_X86_64_PC32	strrchr+0xfffffffffffffffc
 550:	48 89 c3             	mov    %rax,%rbx
  if (q) *q = '\0';
 553:	48 85 db             	test   %rbx,%rbx
 556:	74 03                	je     55b <LACCEPT+0x47>
 558:	c6 03 00             	movb   $0x0,(%rbx)
  return strlen (p);
 55b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 55f:	48 89 c7             	mov    %rax,%rdi
 562:	e8 00 00 00 00       	callq  567 <LACCEPT+0x53>
			563: R_X86_64_PC32	strlen+0xfffffffffffffffc
}
 567:	48 83 c4 18          	add    $0x18,%rsp
 56b:	5b                   	pop    %rbx
 56c:	5d                   	pop    %rbp
 56d:	c3                   	retq   

000000000000056e <LARGV1>:

char* LARGV1() {return ARGV1;}
 56e:	55                   	push   %rbp
 56f:	48 89 e5             	mov    %rsp,%rbp
 572:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 579 <LARGV1+0xb>
			575: R_X86_64_PC32	ARGV1+0xfffffffffffffffc
 579:	5d                   	pop    %rbp
 57a:	c3                   	retq   

000000000000057b <LZTYPE>:

void LZTYPE(char *p)
{ printf("%s\n",p);
 57b:	55                   	push   %rbp
 57c:	48 89 e5             	mov    %rsp,%rbp
 57f:	48 83 ec 10          	sub    $0x10,%rsp
 583:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 587:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 58b:	48 89 c7             	mov    %rax,%rdi
 58e:	e8 00 00 00 00       	callq  593 <LZTYPE+0x18>
			58f: R_X86_64_PC32	puts+0xfffffffffffffffc
}
 593:	c9                   	leaveq 
 594:	c3                   	retq   

0000000000000595 <LBYE>:

void LBYE()
{  exit(0); }
 595:	55                   	push   %rbp
 596:	48 89 e5             	mov    %rsp,%rbp
 599:	bf 00 00 00 00       	mov    $0x0,%edi
 59e:	e8 00 00 00 00       	callq  5a3 <save_term>
			59f: R_X86_64_PC32	exit+0xfffffffffffffffc

00000000000005a3 <save_term>:

struct termios tios0;
char key_query_char = 0;

void save_term ()
{
 5a3:	55                   	push   %rbp
 5a4:	48 89 e5             	mov    %rsp,%rbp
    tcgetattr(0, &tios0);
 5a7:	be 00 00 00 00       	mov    $0x0,%esi
			5a8: R_X86_64_32	tios0
 5ac:	bf 00 00 00 00       	mov    $0x0,%edi
 5b1:	e8 00 00 00 00       	callq  5b6 <save_term+0x13>
			5b2: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
}
 5b6:	5d                   	pop    %rbp
 5b7:	c3                   	retq   

00000000000005b8 <restore_term>:

void restore_term ()
{
 5b8:	55                   	push   %rbp
 5b9:	48 89 e5             	mov    %rsp,%rbp
    tcsetattr(0, TCSANOW, &tios0);
 5bc:	ba 00 00 00 00       	mov    $0x0,%edx
			5bd: R_X86_64_32	tios0
 5c1:	be 00 00 00 00       	mov    $0x0,%esi
 5c6:	bf 00 00 00 00       	mov    $0x0,%edi
 5cb:	e8 00 00 00 00       	callq  5d0 <restore_term+0x18>
			5cc: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
}
 5d0:	5d                   	pop    %rbp
 5d1:	c3                   	retq   

00000000000005d2 <echo_off>:

void echo_off ()
{
 5d2:	55                   	push   %rbp
 5d3:	48 89 e5             	mov    %rsp,%rbp
 5d6:	48 83 ec 40          	sub    $0x40,%rsp
  struct termios t;
  tcgetattr(0, &t);
 5da:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 5de:	48 89 c6             	mov    %rax,%rsi
 5e1:	bf 00 00 00 00       	mov    $0x0,%edi
 5e6:	e8 00 00 00 00       	callq  5eb <echo_off+0x19>
			5e7: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
  t.c_lflag &= ~ECHO;
 5eb:	8b 45 cc             	mov    -0x34(%rbp),%eax
 5ee:	83 e0 f7             	and    $0xfffffff7,%eax
 5f1:	89 45 cc             	mov    %eax,-0x34(%rbp)
  tcsetattr(0, TCSANOW, &t);
 5f4:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 5f8:	48 89 c2             	mov    %rax,%rdx
 5fb:	be 00 00 00 00       	mov    $0x0,%esi
 600:	bf 00 00 00 00       	mov    $0x0,%edi
 605:	e8 00 00 00 00       	callq  60a <echo_off+0x38>
			606: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
}
 60a:	c9                   	leaveq 
 60b:	c3                   	retq   

000000000000060c <echo_on>:

void echo_on ()
{
 60c:	55                   	push   %rbp
 60d:	48 89 e5             	mov    %rsp,%rbp
 610:	48 83 ec 40          	sub    $0x40,%rsp
  struct termios t;
  tcgetattr(0, &t);
 614:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 618:	48 89 c6             	mov    %rax,%rsi
 61b:	bf 00 00 00 00       	mov    $0x0,%edi
 620:	e8 00 00 00 00       	callq  625 <echo_on+0x19>
			621: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
  t.c_lflag |= ECHO;
 625:	8b 45 cc             	mov    -0x34(%rbp),%eax
 628:	83 c8 08             	or     $0x8,%eax
 62b:	89 45 cc             	mov    %eax,-0x34(%rbp)
  tcsetattr(0, TCSANOW, &t);
 62e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 632:	48 89 c2             	mov    %rax,%rdx
 635:	be 00 00 00 00       	mov    $0x0,%esi
 63a:	bf 00 00 00 00       	mov    $0x0,%edi
 63f:	e8 00 00 00 00       	callq  644 <echo_on+0x38>
			640: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
}
 644:	c9                   	leaveq 
 645:	c3                   	retq   

0000000000000646 <C_KEY>:




int C_KEY ()
{
 646:	55                   	push   %rbp
 647:	48 89 e5             	mov    %rsp,%rbp
 64a:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp

  char ch;
  int n;
  struct termios t1, t2;

  if (key_query_char)
 651:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 658 <C_KEY+0x12>
			654: R_X86_64_PC32	key_query_char+0xfffffffffffffffc
 658:	84 c0                	test   %al,%al
 65a:	74 16                	je     672 <C_KEY+0x2c>
    {
      ch = key_query_char;
 65c:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 663 <C_KEY+0x1d>
			65f: R_X86_64_PC32	key_query_char+0xfffffffffffffffc
 663:	88 45 fb             	mov    %al,-0x5(%rbp)
      key_query_char = 0;
 666:	c6 05 00 00 00 00 00 	movb   $0x0,0x0(%rip)        # 66d <C_KEY+0x27>
			668: R_X86_64_PC32	key_query_char+0xfffffffffffffffb
 66d:	e9 d2 00 00 00       	jmpq   744 <C_KEY+0xfe>
    }
  else
    {
      tcgetattr(0, &t1);
 672:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 676:	48 89 c6             	mov    %rax,%rsi
 679:	bf 00 00 00 00       	mov    $0x0,%edi
 67e:	e8 00 00 00 00       	callq  683 <C_KEY+0x3d>
			67f: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
      t2 = t1;
 683:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 687:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
 68e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 692:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
 699:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 69d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 6a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 6a5:	48 89 45 88          	mov    %rax,-0x78(%rbp)
 6a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 6ad:	48 89 45 90          	mov    %rax,-0x70(%rbp)
 6b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 6b5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
 6b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 6bd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
 6c1:	8b 45 e8             	mov    -0x18(%rbp),%eax
 6c4:	89 45 a8             	mov    %eax,-0x58(%rbp)
      t2.c_lflag &= ~ICANON;
 6c7:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
 6cd:	83 e0 fd             	and    $0xfffffffd,%eax
 6d0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
      t2.c_lflag &= ~ECHO;
 6d6:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
 6dc:	83 e0 f7             	and    $0xfffffff7,%eax
 6df:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
//      t2.c_lflag &= ~ISIG;
      t2.c_lflag |= ISIG;
 6e5:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
 6eb:	83 c8 01             	or     $0x1,%eax
 6ee:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
      t2.c_cc[VMIN] = 1;
 6f4:	c6 45 87 01          	movb   $0x1,-0x79(%rbp)
      t2.c_cc[VTIME] = 0;
 6f8:	c6 45 86 00          	movb   $0x0,-0x7a(%rbp)
      tcsetattr(0, TCSANOW, &t2);
 6fc:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
 703:	48 89 c2             	mov    %rax,%rdx
 706:	be 00 00 00 00       	mov    $0x0,%esi
 70b:	bf 00 00 00 00       	mov    $0x0,%edi
 710:	e8 00 00 00 00       	callq  715 <C_KEY+0xcf>
			711: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc

//      do {
	n = read(0, &ch, 1);
 715:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
 719:	ba 01 00 00 00       	mov    $0x1,%edx
 71e:	48 89 c6             	mov    %rax,%rsi
 721:	bf 00 00 00 00       	mov    $0x0,%edi
 726:	e8 00 00 00 00       	callq  72b <C_KEY+0xe5>
			727: R_X86_64_PC32	read+0xfffffffffffffffc
 72b:	89 45 fc             	mov    %eax,-0x4(%rbp)
//      } while (n != 1);

      tcsetattr(0, TCSANOW, &t1);
 72e:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 732:	48 89 c2             	mov    %rax,%rdx
 735:	be 00 00 00 00       	mov    $0x0,%esi
 73a:	bf 00 00 00 00       	mov    $0x0,%edi
 73f:	e8 00 00 00 00       	callq  744 <C_KEY+0xfe>
			740: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
    }
 
  return ch;
 744:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
 748:	0f be c0             	movsbl %al,%eax
}
 74b:	c9                   	leaveq 
 74c:	c3                   	retq   

000000000000074d <C_KEYQUERY>:
/*----------------------------------------------------------*/

int C_KEYQUERY ()
{
 74d:	55                   	push   %rbp
 74e:	48 89 e5             	mov    %rsp,%rbp
 751:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  /* stack: ( a -- b | return true if a key is available ) */

  char ch = 0;
 758:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  int chq;
  struct termios t1, t2;

  if (key_query_char)  return -1;
 75c:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 763 <C_KEYQUERY+0x16>
			75f: R_X86_64_PC32	key_query_char+0xfffffffffffffffc
 763:	84 c0                	test   %al,%al
 765:	74 0a                	je     771 <C_KEYQUERY+0x24>
 767:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 76c:	e9 e9 00 00 00       	jmpq   85a <C_KEYQUERY+0x10d>

      tcgetattr(0, &t1);
 771:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 775:	48 89 c6             	mov    %rax,%rsi
 778:	bf 00 00 00 00       	mov    $0x0,%edi
 77d:	e8 00 00 00 00       	callq  782 <C_KEYQUERY+0x35>
			77e: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
      t2 = t1;
 782:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 786:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
 78d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 791:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
 798:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 79c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 7a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 7a4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
 7a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 7ac:	48 89 45 90          	mov    %rax,-0x70(%rbp)
 7b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 7b4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
 7b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 7bc:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
 7c0:	8b 45 e8             	mov    -0x18(%rbp),%eax
 7c3:	89 45 a8             	mov    %eax,-0x58(%rbp)
      t2.c_lflag &= ~ICANON;
 7c6:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
 7cc:	83 e0 fd             	and    $0xfffffffd,%eax
 7cf:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
      t2.c_lflag &= ~ECHO;
 7d5:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
 7db:	83 e0 f7             	and    $0xfffffff7,%eax
 7de:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
      t2.c_cc[VMIN] = 0;
 7e4:	c6 45 87 00          	movb   $0x0,-0x79(%rbp)
      t2.c_cc[VTIME] = 0;
 7e8:	c6 45 86 00          	movb   $0x0,-0x7a(%rbp)
      tcsetattr(0, TCSANOW, &t2);
 7ec:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
 7f3:	48 89 c2             	mov    %rax,%rdx
 7f6:	be 00 00 00 00       	mov    $0x0,%esi
 7fb:	bf 00 00 00 00       	mov    $0x0,%edi
 800:	e8 00 00 00 00       	callq  805 <C_KEYQUERY+0xb8>
			801: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc

      chq = read(0, &ch, 1) ? -1 : 0;
 805:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
 809:	ba 01 00 00 00       	mov    $0x1,%edx
 80e:	48 89 c6             	mov    %rax,%rsi
 811:	bf 00 00 00 00       	mov    $0x0,%edi
 816:	e8 00 00 00 00       	callq  81b <C_KEYQUERY+0xce>
			817: R_X86_64_PC32	read+0xfffffffffffffffc
 81b:	48 85 c0             	test   %rax,%rax
 81e:	74 07                	je     827 <C_KEYQUERY+0xda>
 820:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 825:	eb 05                	jmp    82c <C_KEYQUERY+0xdf>
 827:	b8 00 00 00 00       	mov    $0x0,%eax
 82c:	89 45 fc             	mov    %eax,-0x4(%rbp)
      if (ch) key_query_char = ch;  
 82f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
 833:	84 c0                	test   %al,%al
 835:	74 0a                	je     841 <C_KEYQUERY+0xf4>
 837:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
 83b:	88 05 00 00 00 00    	mov    %al,0x0(%rip)        # 841 <C_KEYQUERY+0xf4>
			83d: R_X86_64_PC32	key_query_char+0xfffffffffffffffc
      tcsetattr(0, TCSANOW, &t1);
 841:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 845:	48 89 c2             	mov    %rax,%rdx
 848:	be 00 00 00 00       	mov    $0x0,%esi
 84d:	bf 00 00 00 00       	mov    $0x0,%edi
 852:	e8 00 00 00 00       	callq  857 <C_KEYQUERY+0x10a>
			853: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc

  return chq;
 857:	8b 45 fc             	mov    -0x4(%rbp),%eax
}      
 85a:	c9                   	leaveq 
 85b:	c3                   	retq   

000000000000085c <C_ACCEPT>:
/*----------------------------------------------------------*/

int C_ACCEPT (char *cp, int n1 )
{
 85c:	55                   	push   %rbp
 85d:	48 89 e5             	mov    %rsp,%rbp
 860:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
 867:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
 86e:	89 b5 54 ff ff ff    	mov    %esi,-0xac(%rbp)
  /* stack: ( a n1 -- n2 | wait for n characters to be received ) */

  char ch,  *cpstart, *bksp = "\010 \010";
 874:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 87b:	00 
			878: R_X86_64_32S	.rodata+0x8
  int n2, nr;
  struct termios t1, t2;

  cpstart = cp;
 87c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 883:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  tcgetattr(0, &t1);
 887:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
 88b:	48 89 c6             	mov    %rax,%rsi
 88e:	bf 00 00 00 00       	mov    $0x0,%edi
 893:	e8 00 00 00 00       	callq  898 <C_ACCEPT+0x3c>
			894: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
  t2 = t1;
 898:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 89c:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
 8a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 8a7:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
 8ae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 8b2:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
 8b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 8bd:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
 8c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 8c8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 8cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 8d0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
 8d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 8d8:	48 89 45 90          	mov    %rax,-0x70(%rbp)
 8dc:	8b 45 d8             	mov    -0x28(%rbp),%eax
 8df:	89 45 98             	mov    %eax,-0x68(%rbp)
  t2.c_lflag &= ~ICANON;
 8e2:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
 8e8:	83 e0 fd             	and    $0xfffffffd,%eax
 8eb:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  t2.c_lflag &= ~ECHO;
 8f1:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
 8f7:	83 e0 f7             	and    $0xfffffff7,%eax
 8fa:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  t2.c_lflag &= PENDIN;
 900:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
 906:	25 00 40 00 00       	and    $0x4000,%eax
 90b:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)

  t2.c_cc[VMIN] = 1;
 911:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%rbp)
  t2.c_cc[VTIME] = 0;
 918:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%rbp)
  tcsetattr(0, TCSANOW, &t2);
 91f:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
 926:	48 89 c2             	mov    %rax,%rdx
 929:	be 00 00 00 00       	mov    $0x0,%esi
 92e:	bf 00 00 00 00       	mov    $0x0,%edi
 933:	e8 00 00 00 00       	callq  938 <C_ACCEPT+0xdc>
			934: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc


  n2 = 0;
 938:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  while (n2 < n1)
 93f:	e9 b4 00 00 00       	jmpq   9f8 <C_ACCEPT+0x19c>
    {
      nr = read (0, cp, 1);
 944:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 94b:	ba 01 00 00 00       	mov    $0x1,%edx
 950:	48 89 c6             	mov    %rax,%rsi
 953:	bf 00 00 00 00       	mov    $0x0,%edi
 958:	e8 00 00 00 00       	callq  95d <C_ACCEPT+0x101>
			959: R_X86_64_PC32	read+0xfffffffffffffffc
 95d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      if (nr == 1) 
 960:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
 964:	0f 85 8e 00 00 00    	jne    9f8 <C_ACCEPT+0x19c>
	{
	  if (*cp == 10) 
 96a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 971:	0f b6 00             	movzbl (%rax),%eax
 974:	3c 0a                	cmp    $0xa,%al
 976:	0f 84 8d 00 00 00    	je     a09 <C_ACCEPT+0x1ad>
	    break;
	  else if (*cp == 127)
 97c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 983:	0f b6 00             	movzbl (%rax),%eax
 986:	3c 7f                	cmp    $0x7f,%al
 988:	75 49                	jne    9d3 <C_ACCEPT+0x177>
	  {
	    write (0, bksp, 3);
 98a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 98e:	ba 03 00 00 00       	mov    $0x3,%edx
 993:	48 89 c6             	mov    %rax,%rsi
 996:	bf 00 00 00 00       	mov    $0x0,%edi
 99b:	e8 00 00 00 00       	callq  9a0 <C_ACCEPT+0x144>
			99c: R_X86_64_PC32	write+0xfffffffffffffffc
	    --cp; --n2;
 9a0:	48 83 ad 58 ff ff ff 	subq   $0x1,-0xa8(%rbp)
 9a7:	01 
 9a8:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
	    if (cp < cpstart) cp = cpstart;
 9ac:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 9b3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
 9b7:	73 0b                	jae    9c4 <C_ACCEPT+0x168>
 9b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 9bd:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
	    if (n2 < 0) n2 = 0;
 9c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 9c8:	79 2e                	jns    9f8 <C_ACCEPT+0x19c>
 9ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 9d1:	eb 25                	jmp    9f8 <C_ACCEPT+0x19c>
	  }
	  else
	  {
	    write (0, cp, 1);
 9d3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 9da:	ba 01 00 00 00       	mov    $0x1,%edx
 9df:	48 89 c6             	mov    %rax,%rsi
 9e2:	bf 00 00 00 00       	mov    $0x0,%edi
 9e7:	e8 00 00 00 00       	callq  9ec <C_ACCEPT+0x190>
			9e8: R_X86_64_PC32	write+0xfffffffffffffffc
	    ++n2; ++cp;
 9ec:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 9f0:	48 83 85 58 ff ff ff 	addq   $0x1,-0xa8(%rbp)
 9f7:	01 
  t2.c_cc[VTIME] = 0;
  tcsetattr(0, TCSANOW, &t2);


  n2 = 0;
  while (n2 < n1)
 9f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
 9fb:	3b 85 54 ff ff ff    	cmp    -0xac(%rbp),%eax
 a01:	0f 8c 3d ff ff ff    	jl     944 <C_ACCEPT+0xe8>
 a07:	eb 01                	jmp    a0a <C_ACCEPT+0x1ae>
    {
      nr = read (0, cp, 1);
      if (nr == 1) 
	{
	  if (*cp == 10) 
	    break;
 a09:	90                   	nop
	    ++n2; ++cp;
	  }
	}
    }

  tcsetattr(0, TCSANOW, &t1);
 a0a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
 a0e:	48 89 c2             	mov    %rax,%rdx
 a11:	be 00 00 00 00       	mov    $0x0,%esi
 a16:	bf 00 00 00 00       	mov    $0x0,%edi
 a1b:	e8 00 00 00 00       	callq  a20 <C_ACCEPT+0x1c4>
			a1c: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
  return n2;
 a20:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
 a23:	c9                   	leaveq 
 a24:	c3                   	retq   

0000000000000a25 <L_ACCEPT>:

int L_ACCEPT (char *cp, int n1 )
{  struct termios t1, t2;
 a25:	55                   	push   %rbp
 a26:	48 89 e5             	mov    %rsp,%rbp
 a29:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 a30:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
 a37:	89 b5 74 ff ff ff    	mov    %esi,-0x8c(%rbp)
  int n2;
  tcgetattr(0, &t1);
 a3d:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 a41:	48 89 c6             	mov    %rax,%rsi
 a44:	bf 00 00 00 00       	mov    $0x0,%edi
 a49:	e8 00 00 00 00       	callq  a4e <L_ACCEPT+0x29>
			a4a: R_X86_64_PC32	tcgetattr+0xfffffffffffffffc
  t2 = t1;
 a4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 a52:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 a56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 a5a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
 a5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 a62:	48 89 45 90          	mov    %rax,-0x70(%rbp)
 a66:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 a6a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
 a6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 a72:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
 a76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 a7a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
 a7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 a82:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 a86:	8b 45 f8             	mov    -0x8(%rbp),%eax
 a89:	89 45 b8             	mov    %eax,-0x48(%rbp)
  t2.c_lflag |= ICANON;
 a8c:	8b 45 8c             	mov    -0x74(%rbp),%eax
 a8f:	83 c8 02             	or     $0x2,%eax
 a92:	89 45 8c             	mov    %eax,-0x74(%rbp)
  t2.c_lflag |= ECHO;
 a95:	8b 45 8c             	mov    -0x74(%rbp),%eax
 a98:	83 c8 08             	or     $0x8,%eax
 a9b:	89 45 8c             	mov    %eax,-0x74(%rbp)
  t2.c_lflag |= PENDIN;
 a9e:	8b 45 8c             	mov    -0x74(%rbp),%eax
 aa1:	80 cc 40             	or     $0x40,%ah
 aa4:	89 45 8c             	mov    %eax,-0x74(%rbp)

  t2.c_cc[VMIN] = 1;
 aa7:	c6 45 97 01          	movb   $0x1,-0x69(%rbp)
  t2.c_cc[VTIME] = 0;
 aab:	c6 45 96 00          	movb   $0x0,-0x6a(%rbp)
  tcsetattr(0, TCSANOW, &t2);
 aaf:	48 8d 45 80          	lea    -0x80(%rbp),%rax
 ab3:	48 89 c2             	mov    %rax,%rdx
 ab6:	be 00 00 00 00       	mov    $0x0,%esi
 abb:	bf 00 00 00 00       	mov    $0x0,%edi
 ac0:	e8 00 00 00 00       	callq  ac5 <L_ACCEPT+0xa0>
			ac1: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
   n2 = read (0, cp, n1);
 ac5:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
 acb:	48 63 d0             	movslq %eax,%rdx
 ace:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
 ad5:	48 89 c6             	mov    %rax,%rsi
 ad8:	bf 00 00 00 00       	mov    $0x0,%edi
 add:	e8 00 00 00 00       	callq  ae2 <L_ACCEPT+0xbd>
			ade: R_X86_64_PC32	read+0xfffffffffffffffc
 ae2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  tcsetattr(0, TCSANOW, &t1);
 ae5:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 ae9:	48 89 c2             	mov    %rax,%rdx
 aec:	be 00 00 00 00       	mov    $0x0,%esi
 af1:	bf 00 00 00 00       	mov    $0x0,%edi
 af6:	e8 00 00 00 00       	callq  afb <L_ACCEPT+0xd6>
			af7: R_X86_64_PC32	tcsetattr+0xfffffffffffffffc
  return n2;
 afb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
 afe:	c9                   	leaveq 
 aff:	c3                   	retq   

0000000000000b00 <wherexy>:


static int ASCREEN;
static struct {char lines, cols, x, y;} scrn;

int wherexy(void) {								/* 19 */
 b00:	55                   	push   %rbp
 b01:	48 89 e5             	mov    %rsp,%rbp
    lseek(ASCREEN, 0, SEEK_SET); read(ASCREEN, &scrn, 4);
 b04:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # b0a <wherexy+0xa>
			b06: R_X86_64_PC32	.bss
 b0a:	ba 00 00 00 00       	mov    $0x0,%edx
 b0f:	be 00 00 00 00       	mov    $0x0,%esi
 b14:	89 c7                	mov    %eax,%edi
 b16:	e8 00 00 00 00       	callq  b1b <wherexy+0x1b>
			b17: R_X86_64_PC32	lseek+0xfffffffffffffffc
 b1b:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # b21 <wherexy+0x21>
			b1d: R_X86_64_PC32	.bss
 b21:	ba 04 00 00 00       	mov    $0x4,%edx
 b26:	be 00 00 00 00       	mov    $0x0,%esi
			b27: R_X86_64_32	.bss+0x8
 b2b:	89 c7                	mov    %eax,%edi
 b2d:	e8 00 00 00 00       	callq  b32 <wherexy+0x32>
			b2e: R_X86_64_PC32	read+0xfffffffffffffffc
    return ((scrn.x << 16) | (scrn.y & 0xFFFF)); }
 b32:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # b39 <wherexy+0x39>
			b35: R_X86_64_PC32	.bss+0x6
 b39:	0f be c0             	movsbl %al,%eax
 b3c:	89 c2                	mov    %eax,%edx
 b3e:	c1 e2 10             	shl    $0x10,%edx
 b41:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # b48 <wherexy+0x48>
			b44: R_X86_64_PC32	.bss+0x7
 b48:	0f be c0             	movsbl %al,%eax
 b4b:	25 ff ff 00 00       	and    $0xffff,%eax
 b50:	09 d0                	or     %edx,%eax
 b52:	5d                   	pop    %rbp
 b53:	c3                   	retq   

0000000000000b54 <zzzz>:

long long zzzz()
{ return 0x5555777733331111l;
 b54:	55                   	push   %rbp
 b55:	48 89 e5             	mov    %rsp,%rbp
 b58:	48 b8 11 11 33 33 77 	movabs $0x5555777733331111,%rax
 b5f:	77 55 55 
}
 b62:	5d                   	pop    %rbp
 b63:	c3                   	retq   

0000000000000b64 <main>:
main(int argc,char **argv)
{  char kk;
 b64:	55                   	push   %rbp
 b65:	48 89 e5             	mov    %rsp,%rbp
 b68:	48 83 ec 10          	sub    $0x10,%rsp
 b6c:	89 7d fc             	mov    %edi,-0x4(%rbp)
 b6f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   ARGV1=argv[1];
 b73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 b77:	48 8b 40 08          	mov    0x8(%rax),%rax
 b7b:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # b82 <main+0x1e>
			b7e: R_X86_64_PC32	ARGV1+0xfffffffffffffffc
   FP=&FPBuf[FPBufSize-2];
 b82:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # b8d <main+0x29>
 b89:	00 00 00 00 
			b85: R_X86_64_PC32	FP+0xfffffffffffffff8
			b89: R_X86_64_32S	FPBuf+0x1f40
  amain();
 b8d:	b8 00 00 00 00       	mov    $0x0,%eax
 b92:	e8 00 00 00 00       	callq  b97 <main+0x33>
			b93: R_X86_64_PC32	amain+0xfffffffffffffffc
  
  return 0;
 b97:	b8 00 00 00 00       	mov    $0x0,%eax
}
 b9c:	c9                   	leaveq 
 b9d:	c3                   	retq   
